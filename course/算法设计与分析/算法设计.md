## 第一章 复杂性分析初步

> 程序的性能一般指程序的空间复杂性和时间复杂性。
>
> 性能评估主要包含两个方面，即性能分析与性能测量

### 第一节 空间复杂性

>程序所需的空间主要包括：指令空间、数据空间、环境栈空间

### 第二节 时间复杂度

> 时间复杂度的构成: 一个程序所占时间=编译时间+运行时间
>
> 复杂性函数，当以一个多项式函数为上界时，可视为一个好算法(有效算法)
>
> 平均时间复杂度、概率时间复杂度、最坏时间复杂度

### 第三节 渐进符号

> 渐进符号O的定义：$f(n)=O(g(n))当且仅当存在正常数c和n_0,使得对于n\geq n_0,有f(n)\leq cg(n).此时，称g(n)是f(n)的一个上界。$
>
> 符号$\Omega$的定义：$f(n)=\Omega(g(n))当且仅当存在正的常数c和n_0,使得对于所有的n\geq n_0,有f(n)\geq cg(n).此时，称g(n)是f(n)的一个渐进下界。$



## 第二章 图与遍历算法

### 第一节 图的基本概念和术语

> `无向图:`简称图，是一个用线连接在一起的节点的集合。
>
> 没有重复边的图称为`简单图`,`n阶完全图`是指具有n个顶点而且每两个顶点之间都有边连接的简单图。
>
> `k-部图：`是指图的顶点集被分成k个部分，同部分的顶点之间不相邻。
>
> `途径`顶点与边交叉出现的序列，`迹`是指边不重复的途径，`路`是指顶点不重复的途径。起点和终点重合的途径称为`闭途径`，起点和终点重合的迹称为`闭迹`，顶点不重复的闭迹称为`圈`,没有圈的图称为`森林`

### 第二节 图的遍历搜索算法

> 一般树的搜索算法：
>
> + 树的先根次序遍历算法
> + 树的后根次序遍历算法
>
> 一般图的遍历：
>
> + 宽度优先搜索算法（BFS）
> + 深度优先搜索算法（DFS）

### 第三节 双连通与网络可靠性

> 连通无向图G中的顶点v称为`割点`，如果G中去掉v及其关联的边，剩下的图就不再连通。
>
> 当采用深度优先遍历算法时，顶点v被访问的序数称为v的`深索数`，记作DFN(v)
>
> **定义** 顶点u的最低深索数L(u)定义为
>
> ​    L(u):=min{DFN(u),min{DFN(x)|(u,x)是T的余边},min{L(w)|w是u的子节点}}
>
> 可见，如果L(u)$\neq$DFN(u),则必定L(u)<DFN(u),此时,L(u)是通过一条子孙路径所可能到达的顶点的最低深索数。
>
> **结论** 如果u不是深度优先搜索树的根，则u是图G的割点当且仅当u有某个子节点w,w的最低深索数不小于u的深索数，即L(w)$\geq$DFN(u),for some son w of u

<span style='color:red'>判断顶点是否为割点?</span>

### 第四节 对策树



## 第三章 分治算法

### 第一节 算法基本思想

> `分治法:`将整个问题分解为若干个小问题来处理
>
> 递归求最大最小值算法 MaxMin(i,j,fmax,fmin)
>
> 折半搜索

### 第二节 排序算法

> + 归并排序算法
> + 快速排序算法

### 第三节 选择问题

> + 选择排序算法
> + 采用划分的选择算法

###  第四节 关于矩阵乘法

> 分块矩阵

### 第五节 快速Fourier变换

### 第六章 最接近点对问题

## 第四章 贪心算法

### 第一节 贪心算法基本思想

> `贪心算法:`在决策中总是做出在当前看来是最好的选择
>
> 背包问题

### 第二节 调度问题

> 调度问题
>
> + 活动安排问题（在安排时应该将结束时间早的活动尽量往前安排）
> + 带期限的单机作业调度问题(尽量选取效益值大的作业安排)
> + 多机调度问题（需要长时间处理的作业优先处理）

### 第三节 最优生成树问题

> Prim算法
>
> 1. 选择图G的一条权值最小的边e,形成一棵两点一边的子树
> 2. 假设G的一棵子树T已经确定
> 3. 选择G的不在T中的具有最小权值的边e,使得T$\bigcup${e}仍是G的一棵子树
>
> Kruskal算法
>
> 1. 选择图G中的一条权值最小的边e
> 2. 假设已经选好G的一组边L={e,e,...}
> 3. 选择G的不在L中的具有最小权值的边e,使得L$\bigcup${e}诱导出的G的子图不含G的圈。

### 第四节 单点源最短路径问题

> Dijkstra最短路径算法

### 第五节 Huffman编码

### 第六节 贪心算法优性理论

> 一般问题模型： 赋权拟阵的最优化问题

## 第五章 动态规划算法

### 第一节 动态规划算法的基本思想

> 无论过程的初始状态和初始决策是什么，其余的决策都必须相对于初始决策所产生的状态构成一个最优决策序列。
>
> 动态规划算法采用最优性原则来建立递归关系式，在求解问题时有必要验证该递归关系式是否保持最优化原则。
>
> 在使用动态规划算法自顶而下求解时，每次产生的子问题并不总是 新问题，有些子问题反复计算多次，动态规划算法正是利用了这种子问题重叠性，对每一个子问题只计算一次，将其保存在一个表格中，备用。
>
> `最优子结构性质`和`子问题重叠性质`是计算模型采用动态规划算法求解的两个基本要素。
>
> `动态规划算法的基本步骤:`
>
> 1. 分析最优解的结构
> 2. 建立递推关系
> 3. 计算最优值
> 4. 构造最优解

> 多段图问题、0/1背包问题、矩阵连乘问题、

### 第二节 多段图问题

### 第三节 0/1背包问题

### 第四节 流水作业调度问题

### 第五节 最优二叉搜索树

## 第六章 回溯算法

### 第一节 回溯法的基本思想

> 回溯法有‘通用的解题法’之称。应用回溯法求解问题时，首先应明确问题的解空间。一个复杂问题的解决往往由多部分构成，即，一个大的解决方案可以看作是由若干个小的决策组成。很多时候他们构成一个决策序列。
>
> 问题：
>
> + 旅行商问题
> + 定和子集问题
> + n皇后问题
>
> 回溯法解题步骤:
>
> 1. 针对所给的问题，确定问题的解空间；
> 2. 确定易于搜索的解空间结构——状态空间树；
> 3. 以深度优先的方式搜索状态空间树，并且在搜索过程中用剪枝函数避免无效的搜索。

### 第二节 定和子集问题和0/1背包问题

### 第三节 n皇后问题和旅行商问题

### 第四节 图的着色问题

### 第五节 回溯法的效率问题



## 第七章 分枝-限界算法

### 第一节 算法基本思想

> 回溯法采用深度优先的方式，分枝限界采用宽度优先的方式。
>
> 分枝限界策略：在扩展节点处，首先生成其所有的儿子节点，将那些导致不可行解或者非最优解的儿子节点舍弃，其余儿子节点加入活节点 表中。然后，从活节点表中取出一个节点作为当前扩展节点，重复上述节点扩展过程。
>
> 活节点表中选择扩展节点方式：
>
> 1. 队列式
>
>    这种方式是将活节点表组织成一个队列或者一个栈，并按队列的`先进先出`或`后入先出`原则选取下一个节点作为当前扩展节点。
>
> 2. 优先队列式
>
>    这种方式是将活节点表组织成一个优先队列，并按优先队列给出节点规定的优先级选取优先级最高的下一个节点作为当前扩展节点。
>
> `对于最大值优化问题:`常引用一个可能获得的目标函数值得一个上界CUB(经此节点可能达到的最大‘效益值’)。如果当前扩展节点的儿子节点处的动态上界CUB小于目前所获得的目标函数值prev,则该儿子节点不被放入活节点表。实际上相当于剪掉了状态空间树中以该节点为根的子树。
>
> `对于最小值优化问题：`常引用一个可能出现的目标函数值的一个动态下界CLB(经此节点可能付出的最小‘成本’)，如果当前扩展节点的儿子节点处的动态下界CLB大于目前所获得的目标函数值prev，则该节点不被放入活动节点队列。
>
> `对于只是找可行解的问题:`我们可以考虑如何降低搜索成本。常引用一个可能需要的成本的动态下界CLB，如果当前扩展节点的儿子节点处的动态下界CLB大于目前所知道的到达最小成本答案节点所需要的成本prev，则该节点不放入活节点表。 

### 第二节 0/1背包问题的分枝-限界法

### 第三节 电路板布线问题

### 第四节 优先级的确定与LC-检索

> 成本估计函数：$\hat{c} (X)=f(X)+g(X)$
>
> ​		f(X):状态空间树的根节点到X的搜索成本。
>
> ​		g(X):由X到答案节点的搜索成本。

### 第五节 旅行商问题



## 第八章 NP-完全问题

### 第一节 关于问题及算法的描述

> 为了应用算法复杂性理论，首先要对问题、问题的一般描述、计算模型、算法、算法的复杂性给出严格的定义。
>
> 所谓一个问题是指一个有待回答、通常含有几个取值还未确定的自由变量的一个一般性提问。它由两部分组成：
>
> 1. 对其关于参数的一般性描述；
> 2. 对该问题的答案所应满足的某些特性的说明。
>
> 目前广泛采用的描述问题的方法主要有两种：
>
> 1. 将任一问题转化为所谓的可行性检验问题。
> 2. 把问题转化为判定问题。
>
> 几乎所有的问题都可以直接或间接地转述为判定问题。



> `算法`是指用来求解某一问题的、带有一般性的一步一步的过程。
>
> 算法的描述有三种不同的层次：
>
> 1. 形式描述，即详尽地写出图灵机的状态、转移函数等等，这是最底层也是最详细的描述
> 2. 实现描述，使用日常语言来描述图灵机的运行，如怎样移动读写头，怎样在带上存储数据等，但是不给出状态和转移函数的细节
> 3. 高层描述，它也使用日常语言描述算法，但是忽略实现的模型，这种描述不需要提及机器是怎样管理它的带子或读写头的。

### 第二节 图灵机与确定性算法

> 图灵机本质上是一个具有存储载体的，按照具体的指令可以完成向左或向右移动、放置标记、抹去标记以及在计算终止时停机等四种基本操作的、用于描述算法的语言。
>
> **确定性单带自动机(DTM)** 由一个有限状态控制器、一个读写头和一条双向的具有有限多个格的线性带所组成。
>
> 1. 带中所用字符的一个有限集合$\Gamma$,它应包含输入字符表$\Sigma \sub \Gamma$和一个特别的空白符号$b\in \Gamma - \Sigma$
> 2. 一个有限状态集Q，它包含初始状态$q_0$和两个特有的停机状态$q_Y和q_N$
> 3. 一个转移函数$\delta:(Q-\{q_Y,q_N\})\quad X \quad \Gamma\rightarrow Q\quad X\quad\Gamma\quad X\quad\{l,r\}$$\\(q,s)\mapsto(q\prime,s\prime,\Delta)$
>
> 当前状态、带格中的内容以及读写头所在的位置是图灵机的要素，这三者的整体称为一个格局，图灵机的运行就是根据转移函数发出的指令从一个格局转移到另一个格局。
>
> 只有当一个DTM程序对定义于其输入字符表上的所有可能字符串均（在有限步内）停机时，才称其为一个算法。

### 第三节 NP类问题

> **非确定性单带自动机(NDTM)** 是一种假想的机器。通常有两种方式描述它：多值模型和猜想模块模型。
>
> 1. 带中字符集$\Gamma$,使得$\Sigma\sub\Gamma$,且$b\in\Gamma-\Sigma$
> 2. 有限状态集$Q\supseteq\{q_Y,q_N,q_0\}$
> 3. 多值转移函数$\hat\delta:(Q-\{q_Y,q_N\})\quad X\quad \Gamma\to2^{Qx\Gamma x\{l,r\}}\\(q,s)\mapsto S \sube Qx\Gamma x\{l,r\}$
>
> 确定性图灵机在任一状态下只能完成一种运算，而非确定性图灵机可以被想象为在同一时刻能够独立、并行地完成多种运算(表项在转移函数的多值性)，这显然不现实。
>
>  通过允许作不受限制的并行计算可以对不确定性算法做出明确的解释。每当要作出某种选择时，算法就好像给自己复制了若干副本，每种可能的选择有一个副本，于是，许多副本同时被执行。第一个获得成功的副本将引起其它副本计算的结束。如果一个副本获得不成功的完成则只该副本终止。

### 第四节 NP完全问题

> 研究P=NP问题的两条基本思路：
>
> 1. 证明NP类中的某些问题是难解的，从而得到NP$\neq$P。但是要证明这一点几乎同证明P=NP一样困难。
> 2. 考察NP类中问题之间的关系，从中找到一些具有特殊性质的问题。沿着这一路线人们已经证明了在NP类中存在被称为NP-完全的子类，简称NPC问题，并由此发展了一套著名的NP完全理论。
>
> `定义1` 所谓从一个语言$L_1\sube \Sigma_1^*$到另一个语言$L_2\sube\Sigma_2^*$的多项式变换是指满足下面两个条件的函数$f:\Sigma_1^*\to\Sigma_2^*$
>
> 1. 存在计算f的一个多项式时间DTM程序
> 2. 对于所有的$x\in\Sigma_1^*$有：$x\in L_1$当且仅当$f(x)\in L_2$
>
> 用$L_1\propto L_2$表示存在一个从语言$L_1$到语言$L_2$的多项式变换。
>
> `定义2` 称一个语言L(判定问题$\Pi$)为NP-完全问题(NPC),如果$L\in NP(\Pi \in NP)$且对所有别的语言$L\prime\in NP(判定问题\Pi\prime\in NP)$均有$L\prime\propto L(\Pi\prime\propto\Pi)$
>
> `性质1` $如果L\prime\propto L,则L\in P意味着L\prime\in P$
>
> `性质2` $如果L\prime\propto L而且L\propto L\prime\prime,则L\prime\propto L\prime\prime$
>
> `定理2` $设\Pi是NP完全的，如果P\neq NP,则\Pi \in NP-P$
>
> `定理3` $如果L\prime,L \in NP , L\prime \propto L ,则 L\prime \in NPC \Rightarrow L\in NPC$

> 典型NPC问题：
>
> 1. 三维匹配问题
>
>    例：给定三个互不相交的、均含有q个元素的一个结合W,X,Y，取$M\sube WxXxY$
>
>    问：M包含一个匹配吗？即是说，是否存在一个子集$M\prime\sube M使得|M\prime|=q且M\prime$中任意两个三元组都没有相同的分量
>
> 2. 三元精确覆盖问题
>
>    例：给定有限集合X，|X|=3q,以及X的三元子集族C
>
>    问：C含有X的一个精确覆盖吗？即是说，是否存在一个子族$C\prime\sube C$,使得X的每个元素恰好只出现在$C\prime$的一个三元子集中。
>
> 3. 顶点覆盖问题
>
>    例：给定一个图G(V,E)和一个正整数$K\leq V$
>
>    问：是否存在G的一个顶点数不超过K的覆盖？即是否存在一个顶点子集$V\prime\sube V,|V\prime|\leq K$,使得对于每一条边$\{u,v\}\in E$,u与v中至少有一个属于v
>
> 4. Hamilton回路问题
>
>    例：已知一个图G(V,E)
>
>    问：G含有一个Hamilton回路吗？G的Hamilton回路是指包含图G的所有顶点的简单回路(圈),即是G的顶点的一个排序：$[v_1,v_2,v_3,...,v_n]$,其中n=|V|,使得对所有的$i,1\leq i<n,\{v_i,v_{i+1}\}\in E,\{v_n,v_1\}\in E$
>
> 5. 划分问题
>
>    例：已知一个有限集合A及对于每个$a\in A$的一个权值$s(a)\in Z^+$
>
>    问：是否存在A的一个子集$A\prime \sube A$,使得$\sum_{a\in A\prime}s(a)=\sum_{a\in A-A\prime}s(a)$
>
> 6. 三元可满足性问题3SAT
>
>    例：给定布尔变量的一个有限集合U及定义于其上的子句集$C=\{c_1,c_2,...,c_m\}$，其中|$c_i$|=3,i=1,2,...,m
>
>    问：是否存在U上的一个真赋值，使得C中所有的子句均被满足。

### 第五节 证明新问题是NPC问题的方法

> 证明新问题是NPC问题的一般步骤是:
>
> 1. 证明$\Pi \in NP$
> 2. 选取一个已知的NP完全问题$\Pi\prime$
> 3. 构造一个从$\Pi\prime到\Pi$的变换f
> 4. 证明f为一个多项式变换

### 第六节 NP困难问题

> `定义` 对于问题$\Pi$，如果存在一个NP完全问题$\Pi\prime$，使得$\Pi\prime\propto\Pi$,则称问题$\Pi$是NP困难的。
>
> 第k个最重子集问题、对称旅行商问题

