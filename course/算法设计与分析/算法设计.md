## 第一章 复杂性分析初步

> 程序的性能一般指程序的空间复杂性和时间复杂性。
>
> 性能评估主要包含两个方面，即性能分析与性能测量

### 第一节 空间复杂性

>程序所需的空间主要包括：指令空间、数据空间、环境栈空间

### 第二节 时间复杂度

> 时间复杂度的构成: 一个程序所占时间=编译时间+运行时间
>
> 复杂性函数，当以一个多项式函数为上界时，可视为一个好算法(有效算法)
>
> 平均时间复杂度、概率时间复杂度、最坏时间复杂度

### 第三节 渐进符号

> 渐进符号O的定义：$f(n)=O(g(n))当且仅当存在正常数c和n_0,使得对于n\geq n_0,有f(n)\leq cg(n).此时，称g(n)是f(n)的一个上界。$
>
> 符号$\Omega$的定义：$f(n)=\Omega(g(n))当且仅当存在正的常数c和n_0,使得对于所有的n\geq n_0,有f(n)\geq cg(n).此时，称g(n)是f(n)的一个渐进下界。$



## 第二章 图与遍历算法

### 第一节 图的基本概念和术语

> `无向图:`简称图，是一个用线连接在一起的节点的集合。
>
> 没有重复边的图称为`简单图`,`n阶完全图`是指具有n个顶点而且每两个顶点之间都有边连接的简单图。
>
> `k-部图：`是指图的顶点集被分成k个部分，同部分的顶点之间不相邻。
>
> `途径`顶点与边交叉出现的序列，`迹`是指边不重复的途径，`路`是指顶点不重复的途径。起点和终点重合的途径称为`闭途径`，起点和终点重合的迹称为`闭迹`，顶点不重复的闭迹称为`圈`,没有圈的图称为`森林`

### 第二节 图的遍历搜索算法

> 一般树的搜索算法：
>
> + 树的先根次序遍历算法
> + 树的后根次序遍历算法
>
> 一般图的遍历：
>
> + 宽度优先搜索算法（BFS）
> + 深度优先搜索算法（DFS）

### 第三节 双连通与网络可靠性

> 连通无向图G中的顶点v称为`割点`，如果G中去掉v及其关联的边，剩下的图就不再连通。
>
> 当采用深度优先遍历算法时，顶点v被访问的序数称为v的`深索数`，记作DFN(v)
>
> **定义** 顶点u的最低深索数L(u)定义为
>
> ​    L(u):=min{DFN(u),min{DFN(x)|(u,x)是T的余边},min{L(w)|w是u的子节点}}
>
> 可见，如果L(u)$\neq$DFN(u),则必定L(u)<DFN(u),此时,L(u)是通过一条子孙路径所可能到达的顶点的最低深索数。
>
> **结论** 如果u不是深度优先搜索树的根，则u是图G的割点当且仅当u有某个子节点w,w的最低深索数不小于u的深索数，即L(w)$\geq$DFN(u),for some son w of u

<span style='color:red'>判断顶点是否为割点?</span>

### 第四节 对策树



## 第三章 分治算法

### 第一节 算法基本思想

> `分治法:`将整个问题分解为若干个小问题来处理
>
> 递归求最大最小值算法 MaxMin(i,j,fmax,fmin)
>
> 折半搜索

### 第二节 排序算法

> + 归并排序算法
> + 快速排序算法

### 第三节 选择问题

> + 选择排序算法
> + 采用划分的选择算法

###  第四节 关于矩阵乘法

> 分块矩阵

### 第五节 快速Fourier变换

### 第六章 最接近点对问题

## 第四章 贪心算法

### 第一节 贪心算法基本思想

> `贪心算法:`在决策中总是做出在当前看来是最好的选择
>
> 背包问题

### 第二节 调度问题

> 调度问题
>
> + 活动安排问题（在安排时应该将结束时间早的活动尽量往前安排）
> + 带期限的单机作业调度问题(尽量选取效益值大的作业安排)
> + 多机调度问题（需要长时间处理的作业优先处理）

### 第三节 最优生成树问题

> Prim算法
>
> 1. 选择图G的一条权值最小的边e,形成一棵两点一边的子树
> 2. 假设G的一棵子树T已经确定
> 3. 选择G的不在T中的具有最小权值的边e,使得T$\bigcup${e}仍是G的一棵子树
>
> Kruskal算法
>
> 1. 选择图G中的一条权值最小的边e
> 2. 假设已经选好G的一组边L={e,e,...}
> 3. 选择G的不在L中的具有最小权值的边e,使得L$\bigcup${e}诱导出的G的子图不含G的圈。

### 第四节 单点源最短路径问题

> Dijkstra最短路径算法

### 第五节 Huffman编码

### 第六节 贪心算法优性理论

> 一般问题模型： 赋权拟阵的最优化问题

## 第五章 动态规划算法

### 第一节 动态规划算法的基本思想

> 无论过程的初始状态和初始决策是什么，其余的决策都必须相对于初始决策所产生的状态构成一个最优决策序列。
>
> 动态规划算法采用最优性原则来建立递归关系式，在求解问题时有必要验证该递归关系式是否保持最优化原则。
>
> 在使用动态规划算法自顶而下求解时，每次产生的子问题并不总是 新问题，有些子问题反复计算多次，动态规划算法正是利用了这种子问题重叠性，对每一个子问题只计算一次，将其保存在一个表格中，备用。
>
> `最优子结构性质`和`子问题重叠性质`是计算模型采用动态规划算法求解的两个基本要素。
>
> `动态规划算法的基本步骤:`
>
> 1. 分析最优解的结构
> 2. 建立递推关系
> 3. 计算最优值
> 4. 构造最优解

> 多段图问题、0/1背包问题、矩阵连乘问题、

### 第二节 多段图问题

### 第三节 0/1背包问题

### 第四节 流水作业调度问题

### 第五节 最优二叉搜索树

## 第六章 回溯算法

### 第一节 回溯法的基本思想

> 回溯法有‘通用的解题法’之称。应用回溯法求解问题时，首先应明确问题的解空间。一个复杂问题的解决往往由多部分构成，即，一个大的解决方案可以看作是由若干个小的决策组成。很多时候他们构成一个决策序列。
>
> 问题：
>
> + 旅行商问题
> + 定和子集问题
> + n皇后问题
>
> 回溯法解题步骤:
>
> 1. 针对所给的问题，确定问题的解空间；
> 2. 确定易于搜索的解空间结构——状态空间树；
> 3. 以深度优先的方式搜索状态空间树，并且在搜索过程中用剪枝函数避免无效的搜索。

### 第二节 定和子集问题和0/1背包问题

### 第三节 n皇后问题和旅行商问题

### 第四节 图的着色问题

### 第五节 回溯法的效率问题



## 第七章 分枝-限界算法

### 第一节 算法基本思想

> 回溯法采用深度优先的方式，分枝限界采用宽度优先的方式。
>
> 分枝限界策略：在扩展节点处，首先生成其所有的儿子节点，将那些导致不可行解或者非最优解的儿子节点舍弃，其余儿子节点加入活节点 表中。然后，从活节点表中取出一个节点作为当前扩展节点，重复上述节点扩展过程。
>
> 活节点表中选择扩展节点方式：
>
> 1. 队列式
>
>    这种方式是将活节点表组织成一个队列或者一个栈，并按队列的`先进先出`或`后入先出`原则选取下一个节点作为当前扩展节点。
>
> 2. 优先队列式
>
>    这种方式是将活节点表组织成一个优先队列，并按优先队列给出节点规定的优先级选取优先级最高的下一个节点作为当前扩展节点。
>
> `对于最大值优化问题:`常引用一个可能获得的目标函数值得一个上界CUB(经此节点可能达到的最大‘效益值’)。如果当前扩展节点的儿子节点处的动态上界CUB小于目前所获得的目标函数值prev,则该儿子节点不被放入活节点表。实际上相当于剪掉了状态空间树中以该节点为根的子树。
>
> `对于最小值优化问题：`常引用一个可能出现的目标函数值的一个动态下界CLB(经此节点可能付出的最小‘成本’)，如果当前扩展节点的儿子节点处的动态下界CLB大于目前所获得的目标函数值prev，则该节点不被放入活动节点队列。
>
> `对于只是找可行解的问题:`我们可以考虑如何降低搜索成本。常引用一个可能需要的成本的动态下界CLB，如果当前扩展节点的儿子节点处的动态下界CLB大于目前所知道的到达最小成本答案节点所需要的成本prev，则该节点不放入活节点表。 

### 第二节 0/1背包问题的分枝-限界法

### 第三节 电路板布线问题

### 第四节 优先级的确定与LC-检索

> 成本估计函数：$\hat{c} (X)=f(X)+g(X)$
>
> ​		f(X):状态空间树的根节点到X的搜索成本。
>
> ​		g(X):由X到答案节点的搜索成本。

### 第五节 旅行商问题



## 第八章 NP-完全问题

### 第一节 关于问题及算法的描述

> 为了应用算法复杂性理论，首先要对问题、问题的一般描述、计算模型、算法、算法的复杂性给出严格的定义。
>
> 所谓一个问题是指一个有待回答、通常含有几个取值还未确定的自由变量的一个一般性提问。它由两部分组成：
>
> 1. 对其关于参数的一般性描述；
> 2. 对该问题的答案所应满足的某些特性的说明。
>
> 目前广泛采用的描述问题的方法主要有两种：
>
> 1. 将任一问题转化为所谓的可行性检验问题。
> 2. 把问题转化为判定问题。
>
> 几乎所有的问题都可以直接或间接地转述为判定问题。



> `算法`是指用来求解某一问题的、带有一般性的一步一步的过程。
>
> 算法的描述有三种不同的层次：
>
> 1. 形式描述，即详尽地写出图灵机的状态、转移函数等等，这是最底层也是最详细的描述
> 2. 实现描述，使用日常语言来描述图灵机的运行，如怎样移动读写头，怎样在带上存储数据等，但是不给出状态和转移函数的细节
> 3. 高层描述，它也使用日常语言描述算法，但是忽略实现的模型，这种描述不需要提及机器是怎样管理它的带子或读写头的。

### 第二节 图灵机与确定性算法





