一 单例模式
 定义：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。
 特点：1.单例类只有一个实例
      2.单例类必须自己创建自己的唯一实例
      3.单例类必须给其他所有对象提供这一个实例
 单例模式的要点：
      1.私有的构造方法
      2.指向自己实例的私有静态引用
      3.以自己实例为返回值的静态的公有方法
 单例模式根据实例化对象时机的不同分为两种：
      一种是饿汉式单例，一种是懒汉式单例。
      饿汉式实例在单例类被加载的时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。
      代码如下：
      饿汉式单例：
            public class Singleton{
              private static Singleton Singleton =  new Singleton();
              private Singleton(){}
              public static Singleton getInstance(){
                return Singleton;
              }
            }
      懒汉式单例：
            public class Singleton{
              private static Singleton Singleton;
              private Singleton(){}
              public static synchronized Singleton getInstance(){
                if(singleton == null){
                  singleton = new Singleton();
                }
                return singleton;
              }
            }
      单例模式：双重锁方式
            这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，出创建类以后就没有必要了。
            public class Singleton{
              private static volatile Singleton instance = null;
              private Singleton(){}
              public static Singleton getInstance(){
                if(instance == null){
                  synchronized(Singleton.class){
                    if(instance == null){
                      instance = new Singleton();
                    }
                  }
                }
              }
              return instance;
            }
  单例模式的优点：
      1.在内存中只有一个对象，节省内存空间。
      2.避免频繁的创建销毁对象，可以提高性能。
      3.避免对共享资源的多重占用。
      4.可以全局访问。
  单例模式的缺点：
      1.扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要扩展，只有重写那个类。
      2.隐式使用引起类结构不清晰。
      3.导致程序内存泄漏的问题。
  使用场景：
      由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：
      1.需要频繁实例化然后销毁的对象。
      2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
      3.资源共享的情况下，避免由于资源操作时导致的性能和损耗等。
      4.控制资源的情况下，方便资源之间的互相通信。
  单例模式注意事项：
      只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。
      不要做断开单例类对象与类中的静态引用的危险操作。
      多线程使用单例使用共享资源时，注意线程安全问题。
  关于JAVA中使用单例模式的一些常见问题：
      1.单例模式的对象长时间不用会被JVM垃圾收集器收集吗
        除非人为地断开单例中静态引用到单例对象的联接，否则JVM垃圾收集器是不会回收单例对象的。
        JVM卸载类的判定条件如下：
          1.该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例。
          2.加载该类的ClassLoader已经被回收。
          3.该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
          只有三个条件都满足，JVM才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。



二 工厂模式
  定义：工厂模式是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
       工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。
  工厂模式根据抽象程度的不同分为三种：
      1.简单工厂模式（也叫静态工厂模式）
        实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。
      2.工厂方法模式（也叫多形性工厂）
        工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。
      3.抽象工厂模式（也叫工具箱）
        当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。
  抽象的产品类：定义car 交通工具类
      public interface Car{
        void gotowork();
      }
  定义实际的产品类，总共定义两个，bike和bus分别表示不同的交通工具
      public class Bike implements Car{
        @override
        public void gotowork(){
          System.out.println(“骑自行车去上班！”);
        }
      }
      public class Bus implements Car{
        @override
        public void gotowork(){
          System.out.println(“坐公交车去上班！”);
        }
      }
  定义抽象的工厂接口
      public interface ICarFactory{
        Car getCar();
      }
  具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类
      public class BikeFactory implements ICarFactory{
        @override
        public Car getCar(){
          return new Bike();
        }
      }
      public class BusFactory implements ICarFactory{
        @override
        public Car getCar(){
          return new Bus();
        }
      }
  简单的测试类，来验证不同的工厂能够产生不同的产品对象
      public class TestFactory{
        @Test
        public void test(){
          ICarFactory factory = null;
          //bike
          factory = new BikeFactory();
          Car bike = factory.getCar();
          bike.gotowork();

          //Bus
          factory = new BusFactory();
          Car bus = factory.getCar();
          bus.gotowork();
        }
      }
  工厂模式的优点：
    1.一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。
    2.扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。
    3.屏蔽了产品的具体实现，调用者只关心产品的接口。
  工厂模式的缺点：
    每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。
  工厂模式的使用场景：
    1.一个对象拥有很多子类。
    2.创建某个对象时需要进行许多额外的操作。
    3.系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。
  关于Java的工厂模式的一些常见问题：
    利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？
    使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。
  总结：
    无论是简单工厂模式、工厂模式还是抽象工厂模式，它们在本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。
