# 寄存器
  - 数据寄存器
   - AX,BX,CX,DX
   - SP*堆栈指针*,BP*基址指针*,SI*源地址*,DI*目的地址*
  - 控制寄存器
    - IP*指令指针*,FLAG*标志寄存器*
  - 段落寄存器
    - CS*代码段*,DS*数据段*,SS*堆栈段*,ES*附加段*

|寄存器|用途|
|:-:|:-|
|AX|字乘法，字除法，字I/O|
|AL|字节乘法，字节除法，字节I/O,十进制算数运算   |
|AH   |字节乘法，字节除法   |
|BX   |存储器指针   |
|CX   |串操作或循环控制中的计数器   |
|CL   |移位计数器   |
|DX   |字乘法，字除法，简介I/O   |
|SI   |存储器指针（串操作中的源指针）   |
|DI   |存储器指针（串操作中的目的指针）   |
|BP   |存储器指针（存储堆栈的指针）   |
|SP   |堆栈指针   |

  - 标志寄存器

|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  |  |  |  |OF|DF|IF|TF|SF|ZF||AF||PF||CF|

|访问存储器涉及的方式|正常使用的段寄存器|可选用的段寄存器|偏移|
|:-|:-:|:-:|:-:|
|  取指令 |CS   |无   |IP   |
|堆栈操作   |SS   |无   |SP   |
| 一般数据存取（下列情况除外）  |DS   |CS,ES,SS   |有效地址   |
|源数据串   |DS   |CS,ES,SS   |SI   |
|目的数据串    |ES   |无   |DI   |
|BP作为指针寄存器使用   |SS   |CS,DS,ES   |有效地址   |

# 寻址方式
### 1.立即寻址方式
  操作数就包含在指令中，它作为指令的一部分，跟在操作码后存放在代码段。这种操作数成为立即数。  
  MOV AX, 1234H  
  这种寻址方式主要用于给寄存器或存储单元赋初始值的场合。
### 2.寄存器寻址方式
  MOV SI，AX  
### 3.直接寻址方式
  操作数在存储器中，指令直接包含有操作数的有效地址。  
  MOV AX, [1234H]  
  这种寻址方式常用于处理单个存储器变量的情况。它可实现在64K字节的段内寻址操作数。直接寻址的操作数通常是程序中使用的变量。
### 4.寄存器间接寻址
  操作数在存储器中，操作数有效地址在SI,DI,BX,BP这四个寄存器之一中。在一般情况下，如果有效地址在SI,DI和BX中，则以DS段寄存器之内的内容为段值；如果有效地址在BP中，则以SS段寄存器之内容为段值。  
  MOV AX, [SI]
### 5.寄存器相对寻址方式
  操作数在存储器中，操作数的有效地址是一个基址寄存器（BX,BP）或变址寄存器（SI,DI）的内容加上指令中给定的8位或16位位移量之和。  
  MOV AX, [DI+1234H]  
  MOV AX, 3[DI]  
  这种寻址方式同样可用于表格处理，表格的首地址可设置为指令中的位移量，利用修改基址或变址寄存器的内容来存取表格中的项值。所以，这种方式很有利于实现高级语言中对结构或记录等数据类型所实施的操作。
### 6.基址加变址寻址方式
  操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。  
  MOV AX, [BX+DI]    
  MOV AX, [BX][DI]  
  这种寻址方式适用于数组或表格处理。用基址寄存器存放数组首地址，而用变址寄存器来定位数组中的各元素，或反之。由于两个寄存器的值都可以改变，所以能更加灵活地访问数组或表格中的元素。
### 7.相对基址加变址寻址方式
  操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量相加得到。  
  MOV AX, [BX+DI+1234H]
  MOV AX, 1234H[BX][DI]  
  在指令中给定的8位或16位位移量采用补码形式表示。

# 指令系统
- 指令分组
   1. 数据传送
   2. 算数运算
   3. 逻辑运算
   4. 串操作
   5. 程序控制
   6. 处理器控制
- 指令表示格式  
   [标号:] *指令助记符* [操作数1[,操作数2]] [;注释]  

### 1.数据传送指令
  1. 传送指令  
    MOV DST , SRC
    - CPU内部寄存器之间的数据传送。  
      源和目的寄存器不能同时是段寄存器；代码段寄存器CS不能作为目的；指令寄存器IP既不能作为源，也不能作为目的。
    - 立即数送至通用寄存器或存储单元  
      立即数不能直接传送到段寄存器，立即数不能作为目的
    - 寄存器与存储器间的数据传送  
  2. 交换指令  
    XCHG OPRD1, OPRD2  
    实现通用寄存器与通用寄存器或存储单元之间的数据交换。  
    可以是通用寄存器但不能是段寄存器，也不能同时是存储单元。可采用各种存储器寻址方式来指定存储单元。
  3. 地址传送指令  
    - LEA（Load Effective Address）  
      LEA REG, OPRD  
      该指令把操作数OPRD的有效地址传送到操作数REG。操作数OPRD必须是一个存储器操作数。操作数REG必须是一个16位通用寄存器  
    - LDS (Load pointer into DS)  
      LDS REG， OPRD  
      该指令把操作数OPRD中包含的一个32位地址指针的段值部分送到数据段寄存器DS,把偏移部分送到指令给出的通用寄存器REG。操作数OPRD必须是一个32位的存储器操作数，操作数REG可以是一个16位的通用寄存器，但实际使用的往往是变址寄存器或指针寄存器。
    - LES (Load pointer into ES)  
      LES REG, OPRD  
      该指令把操作数OPRD中所含的32为地址指针的段值部分传送到附加段寄存器ES,把偏移部分送到指令给出的通用寄存器REG.

### 2.堆栈操作指令
  栈底的一端地址较大，栈顶的一端地址较小。堆栈的段值在堆栈段寄存器SS中，堆栈指针寄存器SP始终指向栈顶。  
  堆栈的主要用途：  
   - 现场和返回地址的保护
   - 寄存器内容的保护
   - 传递参数
   - 存储局部变量    

1. 进栈指令PUSH  
  PUSH SRC  
  该指令把源操作数SRC压入堆栈。它先把堆栈指针寄存器SP的值减2,然后把源操作数SRC送入由SP所指的栈顶。遵循“高高底底”原则  
2. 出栈指令POP  
  POP DST  
  该指令从栈顶弹出一个字数据。它先把堆栈指针寄存器SP所指的字数据送至目的操作数DST，然后SP值加2，使其仍指向栈顶。  
  目的操作数DST可以是通用寄存器和段寄存器，也可以是字存储单元。

### 3.标志操作指令
1. 标志传送指令  
  - 指令LAHF（Load AH with Flag）  
    把标志寄存器底8位传送到AH中
  - 指令SAHF（Store AH into Flag）
  - 指令PUSHF  
    把标志寄存器中的内容压入堆栈
  - 指令POPF  
2. 标志位操作指令  
  - 清进位标志指令CLC（CLear Carry flag）
  - 置进位标志指令STC（SeT Carry flag ）
  - 进位标志取反指令CMC（CoMplement Carry flag）
  - 清方向标志CLD（CLear Direction flag）
  - 置方向标志STD（SeT Direction flag）
  - 清中断允许标志CLI(CLear Interrupt enable flag)
  - 置中断允许标志STI(SeT Interrupt enable flag)

### 4.加减运算指令
1. 加法指令
  - 普通加法指令ADD(ADDiton)
  - 带进位加指令ADDC(ADDiton with Carry)  
    OPRD1 <= OPRD1 + OPRD2 + CF  
  - 加1指令INC(INCrement)  
    INC OPRD  
    操作数OPRD可以是通用寄存器，也可以是存储单元
2. 减法指令
  - 普通减法指令SUB(SUBtraction)  
  - 带进(借)位减指令SBB(SUBtraction with Borrow)
  - 减1指令DEC（DECrement）
  - 取补指令NEG(NEGate)
3. 比较指令CMP(ComPare)

### 5.乘除法指令
1. 乘法指令  
  在乘法指令中，一个操作数总是隐含在寄存器AL或者AX中，另一个操作数可以采用除立即数方式以外的任一种寻址方式。  

  - 无符号数乘法指令MUL(MULtiply)  
    MUL OPRD  
    AX <= AL * OPRD（8位）  
    DX:AX <= AX * OPRD（16位）
  - 有符号数乘法指令IMUL(sIgned MULtiply)  
    IMUL OPRD  
2. 除法指令  
  在除法指令中，一个操作数总是隐含在寄存器AX或者是DX和AX中，另一个操作数可以采用除立即数方式外的任一种寻址方式
  - 无符号数除法指令DIV（DIVision）  
    DIV OPRD  
    AL(商):AH(余数) <=   AX / OPRD（8位）  
    AX(商):DX(余数) <= DX:AX / OPRD(16位)
  - 有符号数除法指令IDIV（sIgned DIVision）
3. 符号扩展指令  
  由于除法指令隐含使用字被除数或双字被除数，所以当被除数为字节，或者除数和被除数均为字时，需要在除操作前扩展被除数。为此专门提供了符号扩展指令。
  - 字节转换为字指令CBW(Convert Byte to Word)
  - 字转换位双字指令CWD(Convert Word to Double word)

### 6.逻辑运算和以为指令
1. 逻辑运算指令
  - 否操作指令NOT  
    NOT ORPD
  - 与操作指令AND  
    AND OPRD1， OPRD2
  - 或操作指令OR  
    OR OPRD1, OPRD2  
  - 异或操作指令XOR  
    XOR OPRD1, OPRD2
  - 测试指令TEST  
    TEST  OPRD1, OPRD2
2. 一般移位指令
  SAL OPRD, m ;算术(逻辑)左移指令
  SHL OPRD, m ;逻辑左移指令
  SAR OPRD, m ;算术右移指令
  SHR OPRD，m ;逻辑右移指令
3. 循环移位指令  
  ROL OPRD, m (不包含CF)
  ROR OPRD, m (不包含CF)
  RCL OPRD, m (包含CF)
  RCR OPRD, m (包含CF)
### 7.转移指令  


1. 无条件转移指令  
  JMP 标号
2. 无条件间接转移指令
  JMP OPRD  
  这条指令使控制无条件转移到由操作数OPRD的内容给定的目标地址处。OPRD可以是通用寄存器也可以是字存储单元。
3. 无条件段间直接转移指令  
  JMP FAR PTR 标号
4. 无条件段间间接转移指令
  JMP OPRD  
  这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处。操作数OPRD必须是双字存储单元。
  JMP DWORD PTR [1234H]  
5. 条件转移指令  

|指令格式|转移条件|转移说明|其他说明|
|:-:|:-:|:-:|:-:|
|  JZ(JE) 标号| ZF=1  |等于0转移，或者相等转移   |单个标志   |
|  JNZ(JNE) 标号 |ZF=0   |不等于0转移，或者不相等转移   |单个标志   |
|JS 标号   |SF=1   |为负转移   |单个标志   |
|JNS 标号  |SF=0   |为正转移   |单个标志   |
|JO 标号   |OF=1   |溢出转移   |单个标志   |
|JNO 标号  |OF=0   |不溢出转移   |单个标志   |
|JP(JPE) 标号    |PF=1   |偶转移   |单个标志   |
|JNP(JPO) 标号  |PF=0   |奇转移   |单个标志   |
|JB(JNAE,JC) 标号|CF=1|低于转移，或者不高于等于转移，或则进位标志被置转移|单个标志，无符号数|
|JNB(JAE,JNC) 标号|CF=0|不低于转移，或者高于等于转移，或者进位标志被清转移|单个标志，无符号数|
|JBE(JNA) 符号|(CF或ZF)=1|低于等于转移，或者不高于转移|两个标志，无符号数|
|JNBE(JA) 标号|(CF或ZF)=0|不低于等于转移，或者高于转移|两个标志，无符号数|
|JL(JNGE) 标号|(SF异或OF)=1|小于转移，或者不大于等于转移|两个标志，有符号数|
|JNL(JGE) 标号|(SF异或OF)=0|不小于转移，或者大于等于转移|两个标志，有符号数|
|JLE(JNG) 符号|((SF异或OF)或ZF)=1|小于等于转移，不大于转移|三个标志，有符号数|
|JNLE(JG) 符号|((SF异或OF)或ZF)=0|不小于等于转移，大于转移|三个标志，有符号数|  

6. 循环指令
    - 计数循环指令LOOP  
      LOOP 标号  
      这条指令使寄存器CX的值减1，如果结果不等于0，则转移到标号，否则顺序执行LOOP指令后面的指令。
    - 等于/全零循环指令LOOPZ/LOOPE  
      LOOPZ 标号  
      这条指令使寄存器CX的值减1，如果结果不等于0，并且零标志ZF等于1，那么转移到标号，否则顺序执行。
    - 不等于/非零循环指令LOOPNE/LOOPNZ  
      LOOPNE 标号
    - 跳转指令JCXZ  
      JCXZ 标号  
      该指令实现当寄存器CX的值等于0时转移到标号，否则顺序执行。
